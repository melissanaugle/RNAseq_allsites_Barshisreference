---
title: "DGE_GLM"
author: "Melissa Naugle"
date: "04/27/21"
output: html_document
---

#Used with Barshis transcriptome reference
#All 5 Sites
#just compare heat versus control

#Setup
Load packages and install BiocManager if needed

```{r setup}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("edgeR")
#install.packages("statmod")
library("edgeR")
library("statmod")
library("data.table")

setwd("~/Desktop/GitHub/RNAseq_allsites_Barshisreference/")
```

Import Data
Note: must open matrix and write 'gene' as first column header 

```{r import_data}
#Import gene count data and view the first few rows
#had to add 'gene' to first header row on original txt file to prevent weird error
countsTable <- read.table(file="../data/RSEM/RSEM.isoform.counts.matrix", row.names="gene", sep="\t", header=TRUE)
head(countsTable)
```

Import grouping factors

Note: rearranged reps txt file to match order of counts matrix

```{r groupingfactors}
#import grouping factor and create samples group matrix
reps <- read.table("../data/coral_samples_allheats_v_controls.txt", header = F)
head(reps)
```

Setup grouping factors and create List 


```{r create list}
group <- reps$V1

#create 'DGE list' object
#don't include group yet? #but r blog says to include so we include
#check to make sure row names match group names
y <- DGEList(counts=countsTable, group = group)

names(countsTable)
y

#MAKE SURE SAME ORDER ON REPS SHEET AS IN COUNTS MATRIX
colnames(y) <- reps$V2


```


Filtering and normalization

Jacoby's alternative filtering:

'Here, a gene is only retained if it is expressed at a count-per-million (CPM) above 0.5 in at least two samples
keep <- rowSums(cpm(y) > 0.5) >= 2
summary(keep)'

TMM normalization is performed to eliminate composition biases between libraries.

15109 after filtering
18387 filtered out

```{r norm_and_write_list}

#filter out lowly expressed genes
keep <- filterByExpr(y)

y <- y[keep,,keep.lib.sizes=FALSE]

#view summary of normalized counts
summary(keep)

#normalize library sizes (use trimmed mean m values to eliminate composition biases)
# The default method for computing these scale factors uses a trimmed mean of M-values (TMM) between each pair of samples.
y <- calcNormFactors(y)

#not included in Jacoby's code 
#write normalized
normList <- cpm(y, normalized.lib.sizes = T)
nrow(normList)
write.table(normList, file = "../GLM_edgeR_outputs/glmQLF_normalizedCounts_heat_v_control.csv", sep=",", row.names=T)


```

MD plot to verify 

The performance of the TMM normalization procedure can be examined using meandifference (MD) plots. This visualizes the library size-adjusted log-fold change between two libraries (the difference) against the average log-expression across those libraries (the mean). The following MD plot is generated by comparing sample 1 against an artificial library constructed from the average of all other samples.

Ideally, the bulk of genes should be centred at a log-fold change of zero. This indicates that any composition bias between libraries has been successfully removed. This quality check should be repeated by constructing a MD plot for each sample.

```{r plots_to_verify}
#Verify TMM normalization using a MD plot
jpeg("../GLM_edgeR_outputs/glmQLF_plotNormalizedMD_heat_control.jpg")
plotMD(cpm(y, log=TRUE), column=1) 
abline(h=0, col="red", lty=2, lwd=2) 
dev.off()
```

Make MDS plot


default settings for MDS plot: 
points <- c(15,15,16,16,17,17)
colors <- rep(c("blue", "red"), 3)

```{r MDSplot}
#Use a MDS plot to visualizes the differences between samples
#shape is site and color is treatment
colors <- rep(c("red","blue"),20)
points <- rep(c(17, 16),20)
#Write plot with legend to file
jpeg("../GLM_edgeR_outputs/glmQLF_plotMDS_heat_control.jpg")
plotMDS(y, col=colors[group], pch=points[group], cex = 1.75, xlab = "PC1", ylab = "PC2") 
legend("bottom", legend=levels(group), pch=points, col=colors, ncol=2, cex = 0.75)
dev.off()


```

#Design Matrix

#changed this cause names weren't working?
```{r design_matrix}
#create design object with levels of treatments
design <- model.matrix(~0 + group)
colnames(design) <- c("Control", "Heat")
design #looks good!
```

#Estimate Dispersion 

The NB dispersion is estimated using the estimateDisp function. This returns the DGEList object with additional entries for the estimated NB dispersions for all gene. These estimates can be visualized with plotBCV, which shows the root-estimate, i.e., the biological coefficient of variation for each gene.

estimateDisp has no effect on the downstream analysis, but is nevertheless very useful as it identifies genes that are outliers from the mean-NB dispersion trend.

```{r dispersion}
#recommended to estimate dispersion for GLM
y <- estimateDisp(y,design, robust = T)

y$common.dispersion #0.339 is that good??
#visualize with BCV plot
jpeg("../GLM_edgeR_outputs/glmQLF_plotBCV_heats_controls.jpg")
plotBCV(y)
dev.off()
```

QL Dispersion 

Note that only the trended dispersion is used under the quasi-likelihood (QL) pipeline. The tagwise and common estimates are shown here but will not be used further. For the QL dispersions, estimation can be performed using the glmQLFit function. This returns a DGEGLM object containing the estimated values of the GLM coefficients for each gene, as well as the fitted mean-QL dispersion trend, the squeezed QL estimates and the prior degrees of freedom (df). These can be visualized with the plotQLDisp function.

```{r ql_dispersion}

fit <- glmQLFit(y, design, robust = T) #Setting robust=TRUE in glmQLFit is strongly recommended
head(fit$coefficients)
#plot to QL dispersions and write file
jpeg("../GLM_edgeR_outputs/glmQLF_plotQLDisp_all_heat_v_control.jpg")
plotQLDisp(fit)
dev.off()

```





#Make Contrasts and run Differential Expression all heat control

```{r make_contrasts}
con <- makeContrasts(
  HvE = Heat - Control, levels = design)
#The QL F-test is then applied to identify genes that are DE among the five groups. This combines the three pairwise comparisons into a single F-statistic and p-value. The top set of significant genes can be displayed with topTags.
anov <- glmQLFTest(fit, contrast=con)
topTags(anov)
# anov should show DGE bw control and heat common to all 3 sites. Meaning these are genes that are common to the heat stress response, regardless of pollution level 
#If all three contrasts are present in the contrast matrix, then only the log-fold changes of the first two contrasts are shown in the output of topTags.
is.de <- decideTestsDGE(anov, p.value=0.05)
summary(is.de)
tagsTblANOVA.one.allheatvcontrol <- topTags(anov, n = nrow(anov$table))$table
nrow(tagsTblANOVA.one.allheatvcontrol) #15007 = all



tagsTblANOVA.one.allheatvcontrol.filt <- tagsTblANOVA.one.allheatvcontrol[tagsTblANOVA.one.allheatvcontrol$FDR <= 0.05,]
nrow(tagsTblANOVA.one.allheatvcontrol.filt)

#have not run this yet 
#write.table(tagsTblANOVA.one.allheatvcontrol.filt, file="GLM_edgeR_outputs/data/tagsTblANOVA.one.allheatvcontrol_allsites_FDR0.05.csv", sep=",", row.names=TRUE)


#make list for heatmap of log counts per million
logcpm <- cpm(y, log=TRUE, prior.count = T)

head(logcpm)
nrow(logcpm)
#have not run this yet
write.table(logcpm, file = "../GLM_edgeR_outputs/data/glmlogcpm_all_heat_v_control.csv", sep=",", row.names=T)

#write file for heatmap 
logcpm_FDR0.5_allheatvcontrol <- logcpm[c(row.names(tagsTblANOVA.one.allheatvcontrol.filt)), ]
nrow(tagsTblANOVA.one.allheatvcontrol.filt)
nrow(logcpm_FDR0.5_allheatvcontrol)
#6155 genes

#have not run this yet
write.table(logcpm_FDR0.5_allheatvcontrol, file = "../GLM_edgeR_outputs/data/glmlogcpm_FDR0.5__all_heat_v_control.csv", sep=",", row.names=T)


write.table(tagsTblANOVA.one.allheatvcontrol.filt, file="../GLM_edgeR_outputs/data/tagsTblANOVA.one_all_heat_v_control.csv", sep=",", row.names=TRUE)

```

